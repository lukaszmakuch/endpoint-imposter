<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Endpoint Imposter</title>

  <!-- Flatdoc -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/legacy.js'></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/flatdoc.js'></script>

  <!-- highlighter -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script> 

  <!-- Flatdoc theme -->
  <link  href='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/style.css' rel='stylesheet'>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/script.js'></script>

  <!-- Meta -->
  <meta content="Endpoint Imposter" property="og:title">
  <meta content="Declarative, stateful, fast, and reusable HTTP mocks." name="description">

  <!-- custom css -->
  <link  href='style.css' rel='stylesheet'>

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function (callback) {
        callback(null, document.getElementById('doc').innerHTML)
      },
      highlight: function (code, value) {
        return code;
      }
    });
    $(document).on('flatdoc:ready', function() {
      hljs.initHighlightingOnLoad();
    });
  </script>
  <script id="doc" type="text/markdown" src="index.html">

Matching requests
---------------

### Using patterns

The preferable way to match requests is to use declarative patterns.
Thanks to [sift](https://github.com/crcn/sift.js) you can use a mongodb-like query language.

```js
{
  request: {
    path: '/some-address',
    method: 'POST',
    'headers.x-test': 'abc',
    'query.a': 'x',
    'query.b': { $in: ['y', 'z'] },
    body: {
      a: 'x',
      b: 'y',
    },
  },
  // response: ...
}
```

### Using functions

In these rare cases when a declarative pattern doesn't suit your needs, you may consider using a custom function.

It takes an [Express Request object](https://expressjs.com/en/4x/api.html#req) as its only parameter and it's supposed to return true when the request matches the criteria.

```js
{
  requestMatcher: req => req.method === 'GET' && req.path === '/custom-fn',
  // response: ...
}
```

### Path prefix

In order to prefix the path, please use the `pathPrefix` property.


These patterns behave in the same way.
```js
{
  pathPrefix: 'my-prefix',
  request: { path: '/a' },
  response: // ...
},
```

```js
{
  request: { path: '/my-prefix/a' },
  response: // ...
},
```

The difference is that the former one enables performance optimizations.

Generating responses
---------------

### Using patterns

Send some data by setting the `body` property.

```js
{
  // request: ...
  response: {
    body: 'Hi there!',
  }
},
```

Set the `json` property to send a JSON response.

```js
{
  // request: ...
  response: {
    json: { 'what?': 'nothing...' },
  }
},
```

Use the `status` field to set the HTTP response code.

```js
{
  // request: ...
  response: {
    status: 404,
  }
},
```

Define HTTP headers as a `headers` object.

```js
{
  // request: ...
  response: {
    headers: {
      'X-Test-Header': 'The header content',
    },
  }
},
```

### Using functions

In these rare cases when a declarative pattern doesn't suit your needs, you may consider using a custom function.

It takes an [Express Request object](https://expressjs.com/en/4x/api.html#req) and an [Express Response object](https://expressjs.com/en/4x/api.html#res) as its parameters and it's supposed to send a response by calling methods on the `res` object.

```js
{
  // request: ...
  responseGenerator: (req, res) => 
    res.status(500)
    .set('X-Test-Header', req.query.number)
    .send('ðŸŽ‰'),
},
```

Scenarios
---------------

Real world endpoints don't always return the same responses for the same request. For example, the second `GET /items` request may return more items than the first one, just because an item has been added in the meantime by calling `POST /item`.

So there are three different request-response pairs we may expect.
```js
{
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

Unfortunately, this won't work. Calling `GET /items` will always return `['A', 'B']` and it doesn't matter how many times and when do we call `POST /item`.

Scenarios allow us to express the following requirement in a declarative manner:
> Keep returning `['A', 'B']` unless `POST /item` is called. As soon as `POST /item` responds, calling `GET /items` should return `['A', 'B', 'C']`.

Let's start with associating all three mocks with the same `scenario` - `adding-items`.

```js
{
  scenario: 'adding-items',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  scenario: 'adding-items',
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  scenario: 'adding-items',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

Now it's time to specify the `step` when each mocks is active. 

**The initial step is always called `start`.**

```js
{
  scenario: 'adding-items',
  step: 'start',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  scenario: 'adding-items',
  step: 'start',
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  scenario: 'adding-items',
  step: 'added',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

The last thing to do is to tell Endpoint Imposter when should the current step change from `start` to `added`.

We have two options:

1. `afterRequest` - the transition occurs as soon as the request hits the mocked server.
2. `afterResponse` - the transition happens only after the response is sent.

This distinction is especially important when we manually control when responses are sent back.

In our example we're going to use `afterResponse`.

```js
{
  scenario: 'adding-items',
  step: 'start',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  scenario: 'adding-items',
  step: 'start',
  afterResponse: 'added',
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  scenario: 'adding-items',
  step: 'added',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

  </script>
</head>
<body role='flatdoc'>

  <div class='header'>
    <div class='left'>
      <h1>Endpoint Imposter</h1>
      <ul>
        <li><a href='https://github.com/lukaszmakuch/endpoint-imposter'>View on GitHub</a></li>
        <li><a href='https://github.com/lukaszmakuch/endpoint-imposter/issues'>Issues</a></li>
      </ul>
    </div>
    <div class='right'>
      <!-- GitHub buttons: see https://ghbtns.com -->
      <iframe src="https://ghbtns.com/github-btn.html?user=lukaszmakuch&amp;repo=endpoint-imposter&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

</body>
</html>