<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Endpoint Imposter</title>

  <!-- Flatdoc -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/legacy.js'></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/flatdoc.js'></script>

  <!-- highlighter -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script> 

  <!-- Flatdoc theme -->
  <link  href='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/style.css' rel='stylesheet'>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/script.js'></script>

  <!-- Meta -->
  <meta content="Endpoint Imposter" property="og:title">
  <meta content="Declarative, stateful, fast, and reusable HTTP mocks." name="description">

  <!-- custom css -->
  <link  href='style.css' rel='stylesheet'>

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function (callback) {
        callback(null, document.getElementById('doc').innerHTML)
      },
      highlight: function (code, value) {
        return code;
      }
    });
    $(document).on('flatdoc:ready', function() {
      hljs.initHighlightingOnLoad();
    });
  </script>
  <script id="doc" type="text/markdown" src="index.html">

Resources
---------------

Blog posts:

- ðŸ–‹ [What a decent API mocking tool looks like to me](https://lukaszmakuch.pl/post/decent-api-mocking-tool)

Setup
---------------

Create a file called `my-mocks.js` on your desktop and place the following content in it:

```js
module.exports = [
  {
    request: { path: '/todos' },
    response: { json: ['a', 'b', 'c'] },
  }
]
```

Assuming that you have [npm](http://npmjs.com) installed, run this in your terminal:

```none
npx endpoint-imposter --port 3000 --mocks ~/Desktop/my-mocks.js
```

You may need to alter the file path if its different on your machine.

Once you see something like this, you're ready to use Endpoint Imposter!
```none
$ npx endpoint-imposter --port 3000 --mocks ~/Desktop/my-mocks.js
npx: installed 57 in 2.827s
Endpoint Imposter listening on HTTP 3000!
```

Test it by sending a request to `http://localhost:3000/sessionId/todos`:
```none
$ curl http://localhost:3000/sessionId/todos     
["a","b","c"]%  
```

### HTTPS

First, generate a self-signed certificate:
```
openssl req -nodes -new -x509 -keyout server.key -out server.cert
```

Then, tell Endpoint Imposter where to find it and what port should be used to serve over HTTPS:
```
$ npx endpoint-imposter --https-port 3002 --https-key server.key --https-cert server.cert --mocks ~/Desktop/my-mocks.js
```

Sessions
---------------

Sessions allow multiple stateful mocks to run in parallel on a single Endpoint Impostor server.

They isolate the state of mocks.

They are identified by "session identifiers".

Let's say we have mocks that look like this.
```js

{
  scenario: 'stateful',
  step: 'start',
  request: { path: '/read' },
  response: { body: 'A' },
  afterRequest: 'read',
},

{
  scenario: 'stateful',
  step: 'read',
  request: { path: '/read' },
  response: { body: 'B' },
},


```

Assuming that the mocked server is listening on `http://localhost:3000`, then **the application under test should request something like `http://localhost:3000/test-session-id1/read`, not `http://localhost:3000/read`**. 

What's `test-session-id1`? It's a random session identifier.

Think of this root URL suffix as of a cheap way of getting a separate "instance" of the mocks.

From the tested app's point of view, the root URL is always something like `http://localhost:3000/some-string-here`, not just `http://localhost:3000`.

This is how the mock visible above behaves.
```none

the first call in session abc
GET http://localhost:3000/abc/read -> A 

the second call in session abc
GET http://localhost:3000/abc/read -> B 

the first call in session xyz
GET http://localhost:3000/xyz/read -> A 

the third call in session abc
GET http://localhost:3000/abc/read -> B 

the second call in session xyz
GET http://localhost:3000/xyz/read -> B 
```

Most probably you want to generate a random session ID when setting up your test case and then clear it after the test is over.

To clear a session, send a request to `/admin/terminate`. It may be a GET request. Here are some examples: 

```none
http://localhost:3000/admin/terminate?session=abc
http://localhost:3000/admin/terminate?session=xyz
```

Matching requests
---------------

### Using patterns

The preferable way to match requests is to use declarative patterns.
Thanks to [sift](https://github.com/crcn/sift.js) you can use a mongodb-like query language.

```js
{
  request: {
    path: '/some-address',
    method: 'POST',
    'headers.x-test': 'abc',
    'query.a': 'x',
    'query.b': { $in: ['y', 'z'] },
    body: {
      a: 'x',
      b: 'y',
    },
  },
  // response: ...
}
```

### Using functions

In these rare cases when a declarative pattern doesn't suit your needs, you may consider using a custom function.

It takes an [Express Request object](https://expressjs.com/en/4x/api.html#req) as its only parameter and it's supposed to return true when the request matches the criteria.

```js
{
  requestMatcher: req => req.method === 'GET' && req.path === '/custom-fn',
  // response: ...
}
```

### Path prefix

In order to prefix the path, please use the `pathPrefix` property.


These patterns behave in the same way.
```js
{
  pathPrefix: 'my-prefix',
  request: { path: '/a' },
  response: // ...
},
```

```js
{
  request: { path: '/my-prefix/a' },
  response: // ...
},
```

The difference is that the former one enables performance optimizations.

Generating responses
---------------

### Using patterns

Send some data by setting the `body` property.

```js
{
  // request: ...
  response: {
    body: 'Hi there!',
  }
},
```

Set the `json` property to send a JSON response.

```js
{
  // request: ...
  response: {
    json: { 'what?': 'nothing...' },
  }
},
```

Use the `status` field to set the HTTP response code.

```js
{
  // request: ...
  response: {
    status: 404,
  }
},
```

Define HTTP headers as a `headers` object.

```js
{
  // request: ...
  response: {
    headers: {
      'X-Test-Header': 'The header content',
    },
  }
},
```

### Using functions

In these rare cases when a declarative pattern doesn't suit your needs, you may consider using a custom function.

It takes an [Express Request object](https://expressjs.com/en/4x/api.html#req) and an [Express Response object](https://expressjs.com/en/4x/api.html#res) as its parameters and it's supposed to send a response by calling methods on the `res` object.

```js
{
  // request: ...
  responseGenerator: (req, res) => 
    res.status(500)
    .set('X-Test-Header', req.query.number)
    .send('ðŸŽ‰'),
},
```

### Delaying

You can write robust tests covering how does your application behave after a request is sent but before the response arrives through the means of manually released responses.

Let's say that you have a simple endpoint that returns some data:
```js
{
  request: { path: '/read' },
  response: { body: 'ðŸŽ‰' },
},
```

Your application makes a request to `/read` and is expected to process `ðŸŽ‰` as soon as it arrives.

But how does it behave in the meantime, when the request is ongoing?

How to test it in a fast and robust way?

Unlike many other tools, Endpoint Imposter doesn't even offer means of waiting x milliseconds before sending the response.

Why? Because of robustness and speed.

If a mocked server waits 500ms before sending a response, is this enough for the test case to make all the necessary assertions? Maybe. Sometimes. We don't know. And what if the test is very fast? Then it needs to wait, doing nothing, until the mocked server responds.

Endpoint Imposter tackles this with release keys.

First, we associate a release key with the mock. Here it's `give_results`.

```js
{
  request: { path: '/read' },
  response: { body: 'ðŸŽ‰' },
  releaseOn: 'give_results',
},
```

When the system under test tries to fetch `/read`, the request will start, but it won't finish.

It will be pending until the test case calls an address like this:
```none
/admin/release?session=my-session&key=give_results
```
Only then the mocked server will send the response to the application being tested.

That way the test always has enough time to make all the necessary assertions and the mocked server responds as soon as the test is ready to continue.


`/admin/release?session=sessionId&key=releaseKey` sends all the pending responses. It responds with HTTP 400 if there are no pending responses.

`/admin/releaseOneRight?session=sessionId&key=releaseKey` sends the response to the most recent request. It responds with HTTP 400 if there are no more pending responses.

`/admin/releaseOne?session=sessionId&key=releaseKey` sends the response to the oldest request. It responds with HTTP 400 if there are no more pending responses.

Scenarios
---------------

Real world endpoints don't always return the same responses for the same request. For example, the second `GET /items` request may return more items than the first one, just because an item has been added in the meantime by calling `POST /item`.

So there are three different request-response pairs we may expect.
```js
{
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

Unfortunately, this won't work. Calling `GET /items` will always return `['A', 'B']` and it doesn't matter how many times and when do we call `POST /item`.

Scenarios allow us to express the following requirement in a declarative manner:
> Keep returning `['A', 'B']` unless `POST /item` is called. As soon as `POST /item` responds, calling `GET /items` should return `['A', 'B', 'C']`.

Let's start with associating all three mocks with the same `scenario` - `adding-items`.

```js
{
  scenario: 'adding-items',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  scenario: 'adding-items',
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  scenario: 'adding-items',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

Now it's time to specify the `step` when each mocks is active. 

**The initial step is always called `start`.**

```js
{
  scenario: 'adding-items',
  step: 'start',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  scenario: 'adding-items',
  step: 'start',
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  scenario: 'adding-items',
  step: 'added',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

The last thing to do is to tell Endpoint Imposter when should the current step change from `start` to `added`.

We have two options:

1. `afterRequest` - the transition occurs as soon as the request hits the mocked server.
2. `afterResponse` - the transition happens only after the response is sent.

This distinction is especially important when we manually control when responses are sent back.

In our example we're going to use `afterResponse`.

```js
{
  scenario: 'adding-items',
  step: 'start',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B'] },
},

{
  scenario: 'adding-items',
  step: 'start',
  afterResponse: 'added',
  request: {
    method: 'POST',
    path: '/item',
    body: { content: 'C' },
  },
  response: { status: 204 },
},

{
  scenario: 'adding-items',
  step: 'added',
  request: { method: 'GET', path: '/items' },
  response: { json: ['A', 'B', 'C'] },
},
```

  </script>
</head>
<body role='flatdoc' class="no-literate">

  <div class='header'>
    <div class='left'>
      <h1>Endpoint Imposter</h1>
      <ul>
        <li><a href='https://github.com/lukaszmakuch/endpoint-imposter'>View on GitHub</a></li>
        <li><a href='https://github.com/lukaszmakuch/endpoint-imposter/issues'>Issues</a></li>
      </ul>
    </div>
    <div class='right'>
      <!-- GitHub buttons: see https://ghbtns.com -->
      <iframe src="https://ghbtns.com/github-btn.html?user=lukaszmakuch&amp;repo=endpoint-imposter&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

</body>
</html>